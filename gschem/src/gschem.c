/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2013 Ales Hvezda
 * Copyright (C) 1998-2013 gEDA Contributors (see ChangeLog for details)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
#include <config.h>
#include <version.h>
#include <missing.h>

#include <X11/Xlib.h>

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <glib.h>

#include "gschem.h"

#ifdef HAVE_LIBDMALLOC
#include <dmalloc.h>
#endif

#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

/* These are generated by parse_commandline() */
extern SCM s_pre_load_expr;
extern SCM s_post_load_expr;

typedef struct {
  void (*func)(void*);
  void* arg;
} geda_atexit_struct;

static GList*     exit_functions  = NULL;
static GMainLoop* main_loop       = NULL;

void shut_down_gui (void)
{
  g_main_loop_unref(main_loop);
  g_main_loop_quit(main_loop);
}

/*! \brief Register a function to be called on program exit
 *
 *  \par Function Description
 *  This function registers a function to be called on
 *  program exit. Multiple functions will be executed in
 *  the order they are registered.
 *
 *  \param [in] func a pointer to the function to be registered
 *  \param [in] data an arbitrary argument provided to the function
 *                   when it is called
 */
void geda_atexit(geda_atexit_func func, void* data)
{
  geda_atexit_struct *p;

  p = g_new(geda_atexit_struct, 1);
  p->func = func;
  p->arg = data;
  exit_functions = g_list_append(exit_functions, p);
}

/*! \brief Cleanup gSchem on exit.
 *  \par Function Description
 *  This function cleans up all memory objects allocated during the
 *  gSchem runtime.
 */
void gschem_quit(void)
{
  GList *list;
  geda_atexit_struct *p;

  /* Call all registered functions in order */
  list = exit_functions;
  while(list != NULL) {
    p = (geda_atexit_struct *) list->data;
    p->func(p->arg);
    g_free(p);
    list = g_list_next(list);
  }
  g_list_free(exit_functions);

  s_clib_free();
  s_slib_free();
  s_attrib_free();
  s_papersizes_free();
  x_color_free();
  x_menu_free_all();

#ifdef HAVE_LIBSTROKE
  x_stroke_free ();
#endif /* HAVE_LIBSTROKE */
  o_undo_cleanup();

  i_vars_freenames();
  i_vars_libgeda_freenames();

  /* enable this to get more memory usage from glib */
  /* You also have to enable something in glib I think */
  /* g_mem_profile();*/
}

void gschem( int argc, char *argv[])
{
  int i;
  char *cwd = NULL;
  GSCHEM_TOPLEVEL *w_current = NULL;
  char *input_str = NULL;
  int argv_index;
  int first_page = 1;

  char *filename;
  char  tmpfilename[MAX_PATH];
  SCM scm_tmp;

  argv_index = parse_commandline(argc, argv);

  libgeda_init();

#if defined(__MINGW32__) && defined(DEBUG)
  fprintf(stderr, _("This is the MINGW32 port.\n"));
#endif

  /* init global buffers */
  o_buffer_init();

  /* register guile (scheme) functions */
  g_register_funcs();
  g_init_window ();
  g_init_select ();
  g_init_hook ();
  g_init_attrib ();
  g_init_keys ();
  g_init_util ();

  /* initialise color map (need to do this before reading rc files */
  x_color_init ();

  o_undo_init();

  if (s_path_sys_data () == NULL) {
    const gchar *message =
      _("You must set the GEDADATA environment variable!\n\n"
        "gschem cannot locate its data files. You must set the GEDADATA\n"
        "environment variable to point to the correct location.\n");
    GtkWidget* error_diag =
      gtk_message_dialog_new (NULL, 0, GTK_MESSAGE_ERROR,
                              GTK_BUTTONS_OK,
                              "%s", message);
    gtk_dialog_run (GTK_DIALOG (error_diag));
    g_error ("%s", message);
  }

  /* Allocate w_current */
  w_current = gschem_toplevel_new ();
  w_current->toplevel = s_toplevel_new ();

  w_current->toplevel->load_newer_backup_func = x_fileselect_load_backup;

  o_text_set_rendered_bounds_func (w_current->toplevel,
                                   o_text_get_rendered_bounds, w_current);

  /* Damage notifications should invalidate the object on screen */
  o_add_change_notify (w_current->toplevel,
                      (ChangeNotifyFunc) o_invalidate,
                      (ChangeNotifyFunc) o_invalidate, w_current);

  scm_dynwind_begin (0);
  g_dynwind_window (w_current);

  /* Run pre-load Scheme expressions */
  g_scm_eval_protected (s_pre_load_expr, scm_current_module ());

  /* By this point, libgeda should have setup the Guile load path, so
   * we can take advantage of that.  */
  scm_tmp = scm_sys_search_load_path (scm_from_utf8_string ("gschem.scm"));
  if (scm_is_false (scm_tmp)) {
    s_log_message (_("Unable to locate scm initialization file \"gschem.scm\"\n"));
  }
  else {
    input_str = scm_to_utf8_string (scm_tmp);
    if (g_read_file(w_current->toplevel, input_str, NULL)) {
      if(!quiet_mode) {
        s_log_message(_("Read init scm file [%s]\n"), input_str);
      }
    } else {
      s_log_message(_("Failed to read init scm file [%s]\n"), input_str);
    }
  }
  free (input_str); /* M'allocated by scm_to_utf8_string() */
  scm_remember_upto_here_1 (scm_tmp);

  /*! \internal Initialize Settings */
  i_vars_init(w_current);         /* Set defaults */

  if (w_current->save_ui_settings)
    geda_atexit (i_vars_atexit_save_user_config, NULL);

  /*! \internal Setup Log & Console Systems */
  /*TODO: All of this logging stuff should be relocated to Lib */
  /* Now that the initialization files have been processed, retrieve the log settings. */
  logging             = default_logging;
  log_destiny         = default_log_destiny;
  console_window      = default_console_window;
  console_window_type = default_console_window_type;

  x_console_init_commands(w_current, run_mode);

  if (logging == TRUE) {
    s_log_init ("gschem");

    /* see if open up log window on startup  */
    if (console_window == MAP_ON_STARTUP) {  /* This assumes MAP to Window */
      x_console_open (w_current);
    }
    /* now we can spam the log */
    s_log_message(_("gEDA/gschem version %s%s.%s\n"), PREPEND_VERSION_STRING,
                     PACKAGE_DOTTED_VERSION, PACKAGE_DATE_VERSION);
  }
  else
    s_log_message("Logging system is disabled");

  /*! \endinternal Log & Console Systems */

  auto_load_last = default_auto_load_last;

  /* Load recent files list before calling x_window_setup.*/
  recent_files_load();
  geda_atexit(recent_files_save, NULL);

  /* Set default icon */
  x_window_set_default_icon();

  /* At end, complete set up of window. */
  x_color_allocate();
  x_window_setup (w_current);
#ifdef HAVE_LIBSTROKE
  x_stroke_init ();
#endif /* HAVE_LIBSTROKE */

  cwd = g_get_current_dir();
  for (i = argv_index; i < argc; i++) {

    if (g_path_is_absolute(argv[i]))
    {
      /* Path is already absolute so no need to do any concat of cwd */
      filename = g_strdup (argv[i]);
    } else {
      filename = g_build_filename (cwd, argv[i], NULL);
    }

    /* if filename is not valid */
    if( access( filename, F_OK ) == -1 ) {
      /* See if user left off our file suffixes */
      if (strcmp (get_filename_ext(filename), SCHEMATIC_FILE_SUFFIX) != 0)
      {
        /* Check if file name is valid if ".sch" is added */
        strcpy(tmpfilename, filename);
        if( access( strcat(tmpfilename, SCHEMATIC_FILE_DOT_SUFFIX), F_OK ) != -1 ) {
          filename = tmpfilename;
          if(verbose_mode) {
            s_log_message("Assumming schematic file suffix for [%s]\n", basename (filename));
          }
        } else
        {
          /* Check if file name is valid if ".sym" is added */
          strcpy(tmpfilename, filename);
          if( access( strcat(tmpfilename, SYMBOL_FILE_DOT_SUFFIX), F_OK ) != -1 ) {
            filename = tmpfilename;
            if(verbose_mode) {
              s_log_message("Assumming symbol file suffix for [%s]\n", basename (filename));
            }
          }
        }
      }
    }

    if ( first_page )
      first_page = 0;

    /*
     * SDB notes:  at this point the filename might be unnormalized, like
     * /path/to/foo/../bar/baz.sch.  Bad filenames will be normalized in
     * f_open (called by x_window_open_page). This works for Linux and MINGW32.
     */

    x_window_open_page(w_current, filename);

    /* Free the pointer if we did not redirected */
    if ( filename != tmpfilename )
        g_free (filename);
  }
  g_free(cwd);

  /*! \brief Auto-Load */

  /* Check and do Auto Load - only works if empty commandline */
  if((argc == 1) && (auto_load_last) && (recent_files_last() != NULL)) {
    q_log_message("Auto loading . . .\n"); /* maybe Log what we're doing */
    x_window_open_page(w_current, recent_files_last());
  }
  else
  {   /* If no page has been loaded (wasn't specified in the command line.) */
      /* Then create an untitled page */
    if ( first_page ) {
        x_window_open_page( w_current, NULL );
     }
  }

  /* Update the window to show the current page */
  x_window_set_current_page( w_current, w_current->toplevel->page_current );

#if DEBUG
  scm_c_eval_string ("(display \"hello guile\n\")");
#endif

  /* Run post-load expressions */
  g_scm_eval_protected (s_post_load_expr, scm_current_module ());

  /* if there were any symbols which had major changes, show error dialog */
  x_dialog_symbol_changed(w_current);

  scm_dynwind_end ();

}
/*! \brief Main Scheme(GUILE) program function.
 *  \par Function Description
 *  This function is the main program called from scm_boot_guile.
 *  It handles initializing all libraries and gSchem variables
 *  and passes control to the gtk main loop.
 */
void main_prog(void *closure, int argc, char *argv[])
{

  XInitThreads();

#ifdef HAVE_GTHREAD

  /* Initialise threading before any other GLib functions are called. */

#if (( GLIB_MAJOR_VERSION == 2 ) && ( GLIB_MINOR_VERSION < 32 ))
  g_thread_init (NULL);
#endif

  if (g_thread_supported ()) {
    gdk_threads_init();
    run_mode = 2;
  }
#else
    run_mode = 1;
#endif


#if ENABLE_NLS
  /* This should be equivalent to setlocale (LC_ALL, "") */
  gtk_set_locale();

  /* This must be the same for all locales */
  setlocale(LC_NUMERIC, "C");

  /* Disable gtk's ability to set the locale. If gtk is allowed to set the
   * locale, then it will override the setlocale for LC_NUMERIC (which is
   * important for proper PS output. This may look funny here, given we make
   * a call to gtk_set_locale() above. Is this really the right thing to do?
   */
  gtk_disable_setlocale();

#if DEBUG
  fprintf(stderr, _("Current locale settings: %s\n"), setlocale(LC_ALL, NULL));
#endif
#endif
  //g_mem_set_vtable (glib_mem_profiler_table);

  gtk_init(&argc, &argv);

  gschem(argc, argv);

  /* enter main loop */
  main_loop    = g_main_loop_new (NULL, FALSE);

  g_main_loop_run(main_loop);

  gschem_quit();

}

/*! \brief Main executable entrance point.
 *  \par Function Description
 *  This is the main function for gSchem. It sets up the Scheme(GUILE)
 *  environment and passes control to via scm_boot_guile to
 *  the #main_prog function.
 */
int main (int argc, char *argv[])
{

#if ENABLE_NLS
  setlocale(LC_ALL, "");
  setlocale(LC_NUMERIC, "C");
  bindtextdomain("geda-gschem", LOCALEDIR);
  textdomain("geda-gschem");
  bind_textdomain_codeset("geda-gschem", "UTF-8");
#endif

  scm_boot_guile (argc, argv, main_prog, 0);
  return 0;
}
