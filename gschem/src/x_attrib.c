/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2013 Ales Hvezda
 * Copyright (C) 1998-2013 gEDA Contributors (see ChangeLog for details)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301 USA
 */

#include <config.h>

#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include "gschem.h"
#include "x_dialog.h"
#include "geda_dialog_controls.h"
#include "widgets.h"

#ifdef HAVE_LIBDMALLOC
#include <dmalloc.h>
#endif

/***************** Start of Attrib Edit dialog box ********************/

typedef enum
{
  /* This dialog is used for both edit and creating new attributes */
  SAE_EDIT_MODE,
  SAE_ADD_MODE
} AttributeEditMode;

/*! \section attrib-edit-dialog-box Attrib Edit Dialog Box */

/*! \brief Callback for Editing Text Properties
 *  \par Function Description
 *   This function updates widgets on the attrib_edit dialog with the text
 * properties of the passed object. If multible objects are selected
 * the text editing field is set to NULL.
 *
 */
static void x_dialog_attrib_edit_update_selection (GschemToplevel *w_current,
                                                   OBJECT *object)
{
  GtkWidget *ThisDialog;
  GtkWidget *widget;
  TOPLEVEL  *toplevel;
  char      *name = NULL;
  char      *val  = NULL;
  //int        mode_flag;
  int        len  = 0;

  ThisDialog = w_current->aewindow;
  toplevel   = w_current->toplevel;

  // mode_flag =  GPOINTER_TO_INT( g_object_get_data(G_OBJECT(ThisDialog), "mode_flag") );

  if (object != NULL && object->type == OBJ_TEXT) {

    /* Update the visibility button widget*/
    widget = g_object_get_data(G_OBJECT(ThisDialog), "visbutton");
    if (o_is_visible (toplevel, object)) {
      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), TRUE);
    }
    else {
      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), FALSE);
    }

    /* Update Show Options */
    widget = g_object_get_data(G_OBJECT(ThisDialog), "show_options");
    if (object->show_name_value == SHOW_VALUE) {
      gtk_option_menu_set_history (GTK_OPTION_MENU (widget), 0);
    }
    else if (object->show_name_value == SHOW_NAME) {
      gtk_option_menu_set_history (GTK_OPTION_MENU (widget), 1);
    }
    else {
      gtk_option_menu_set_history (GTK_OPTION_MENU (widget), 2);
    }

    /* Get the attribute name and value string components */
    o_attrib_get_name_value (object, &name, &val);

    /* Update the Value Entry */
    widget = g_object_get_data(G_OBJECT(ThisDialog), "value_entry");
    if (val) {
      gtk_entry_set_text(GTK_ENTRY(widget), val);
      len = strlen(val);
      gtk_entry_select_region(GTK_ENTRY(widget), 0, len);
    }

    widget = g_object_get_data(G_OBJECT(ThisDialog), "attrib_combo_entry");
    gtk_entry_set_text(GTK_ENTRY(widget), name);

    g_free(name);
    g_free(val);

  }

  g_object_set_data(G_OBJECT(ThisDialog), "attrib", object);

}
/*! \todo Finish function documentation!!!
 *  \brief
 *  \par Function Documentation
 *
 */
int option_menu_get_history (GtkOptionMenu *option_menu)
{
  GtkWidget *active_widget;

  g_return_val_if_fail (GTK_IS_OPTION_MENU (option_menu), -1);

  active_widget = gtk_menu_get_active (GTK_MENU (option_menu->menu));

  if (active_widget)
    return g_list_index (GTK_MENU_SHELL (option_menu->menu)->children,
                         active_widget);
    else
      return -1;
}

/*! \brief Single Attribute Editor Dialog Response Handler
 *  \par Function Documentation
 *  This function handles signals generated by the button widgets
 *  in the dialog's action area. There are only two signal, one for
 *  "apply" and one to "close" the dialog.
 * 
 * \param mode flag to indicate create mode or edit an existing
 * \param w_current is pointer to a GschemToplevel structure
 */
static void
attrib_edit_dialog_ok(AttributeEditMode mode, GschemToplevel *w_current)
{
  TOPLEVEL  *toplevel;
  GtkWidget *ThisDialog;

  GtkEntry   *value_entry;
  GtkEntry   *name_entry;
  GtkWidget  *visbutton;
  GtkWidget  *show_options;

  OBJECT     *object;

  const char *value, *label;
  char       *newtext;
  int vis, show;

  int option_index;

  ThisDialog = w_current->aewindow;
  toplevel   = w_current->toplevel;

  value_entry  = g_object_get_data(G_OBJECT(ThisDialog), "value_entry");
  name_entry   = g_object_get_data(G_OBJECT(ThisDialog), "attrib_combo_entry");
  visbutton    = g_object_get_data(G_OBJECT(ThisDialog), "visbutton");
  show_options = g_object_get_data(G_OBJECT(ThisDialog), "show_options");

  value   = gtk_entry_get_text(value_entry);
  label   = gtk_entry_get_text(name_entry);
  newtext = g_strconcat (label, "=", value, NULL);

  if (!x_dialog_validate_attribute(GTK_WINDOW(ThisDialog), newtext))
  {
    g_free(newtext);
    return;
  }

  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(visbutton)))
    vis = VISIBLE;
  else
    vis = INVISIBLE;

  option_index = option_menu_get_history(GTK_OPTION_MENU (show_options));
  switch(option_index) {
    case(0):
      show = SHOW_VALUE;
      break;

    case(1):
      show = SHOW_NAME;
      break;

    case(2):
      show = SHOW_NAME_VALUE;
      break;

    default:
      fprintf(stderr, _("Got invalid show option; defaulting to show both\n"));
      show = SHOW_NAME_VALUE;
      break;
  }

  if (mode == SAE_ADD_MODE) {

    OBJECT *new = NULL;

    object = o_select_return_first_object(w_current);

    new = o_attrib_add_attrib(w_current, newtext, vis, show, object);

    if ( w_current->first_wx != -1 && w_current->first_wy != -1) {
      o_invalidate (w_current, new);
      new->text->x = w_current->first_wx;
      new->text->y = w_current->first_wy;
      o_text_recreate(toplevel, new);
      toplevel->page_current->CHANGED = 1;
      o_undo_savestate(w_current, UNDO_ALL);
    }
  }
  else {
    object =  g_object_get_data(G_OBJECT(ThisDialog), "attrib");
    if (object != NULL && object->type == OBJ_TEXT) {
      o_text_change(w_current, object, newtext, vis, show);
      toplevel->page_current->CHANGED = 1;
      o_undo_savestate(w_current, UNDO_ALL);
    }
  }
  g_free(newtext);
}

/*! \brief Response function for the attribute add/edit dialog
 *  \par Function Description
 *  This function catches the user response for the add and edit
 *  attribute dialog.
 */
void attribute_edit_dialog_response(GtkWidget *w, int response,
                                    GschemToplevel *w_current)
{
  GtkWidget *ThisDialog;
  ThisDialog = w_current->aewindow;

  switch(response) {
    case GTK_RESPONSE_APPLY:
      attrib_edit_dialog_ok ( SAE_EDIT_MODE, w_current);
      break;
    case GTK_RESPONSE_ACCEPT:
      attrib_edit_dialog_ok ( SAE_ADD_MODE, w_current);
      gtk_grab_remove(ThisDialog);
      break;
    case GTK_RESPONSE_REJECT:
    case GTK_RESPONSE_DELETE_EVENT:
      gtk_widget_destroy(ThisDialog);
      w_current->aewindow = NULL;
      break;
    default:
      printf("attrib_edit_dialog_response(): strange signal %d\n", response);
  }
}

/*! \brief Move Focus when Enter pressed in Name Entry
 *  \par Function Description
 *  This function is call when the ENTER button is press
 *  in Attribute Name entry, the function sets focus to the
 *  Value Entry.
 */
static void
callback_attrib_entry_activate (GtkWidget *w, GtkWidget *value_entry)
{
  if ( GTK_IS_ENTRY(value_entry))
    gtk_widget_grab_focus(value_entry);
}

GtkWidget *x_attrib_option_menu_new()
{
  GtkWidget  *options_menu;
  GtkWidget  *show_options_menu;
  GtkWidget  *menuitem;

  const char *options_menu_tip;
  const char *options_name_tip;
  const char *options_value_tip;
  const char *options_both_tip;

  options_menu_tip  = _("Select to choose an attribute visibility options");
  options_name_tip  = _("Show only the name of the attribute");
  options_value_tip = _("Show only the value of the attribute");
  options_both_tip  = _("Show both the name and the value of the attribute");

  options_menu = gtk_option_menu_new ();
  g_object_set (options_menu, "visible", TRUE, NULL);

  show_options_menu = gtk_menu_new ();
  gtk_widget_set_tooltip_text (GTK_WIDGET(options_menu), options_menu_tip);

  menuitem = gtk_menu_item_new_with_label (_("Show Value Only"));
  gtk_menu_append (GTK_MENU (show_options_menu), menuitem);
  gtk_widget_set_tooltip_text (GTK_WIDGET(menuitem), options_name_tip);

  menuitem = gtk_menu_item_new_with_label (_("Show Name Only"));
  gtk_menu_append (GTK_MENU (show_options_menu), menuitem);
  gtk_widget_set_tooltip_text (GTK_WIDGET(menuitem), options_value_tip);

  menuitem = gtk_menu_item_new_with_label (_("Show Name & Value"));
  gtk_menu_append (GTK_MENU (show_options_menu), menuitem);
  gtk_widget_set_tooltip_text (GTK_WIDGET(menuitem), options_both_tip);

  gtk_option_menu_set_menu (GTK_OPTION_MENU (options_menu), show_options_menu);
  gtk_option_menu_set_history (GTK_OPTION_MENU (options_menu), 0);

  return options_menu;
}
/*! \brief Create the attribute add/edit dialog
 *  \par Function Description
 *  This function creates the single attribute edit dialog. This dialog
 *  is special in that it can be either an "add" new attribute or an
 *  "Edit" (existing) attribute dialog.
 *
 */
static
void attrib_edit_dialog (GschemToplevel *w_current, OBJECT *object, int flag)
{
  AtkObject  *atk_name_obj;
  AtkObject  *atk_value_obj;

  GtkWidget  *ThisDialog;
  GtkWidget  *vbox, *label, *table, *alignment;
  GtkWidget  *name_label, *value_label;
  GtkWidget  *show_options;
  GtkWidget  *attrib_combo_box_entry;
  GtkWidget  *attrib_combo_entry;
  GtkWidget  *value_entry;
  GtkWidget  *visbutton;

  GtkEntryCompletion *attrib_combo_entry_completion;
  GtkResponseType     response;
  GschemDialogFlags   dialog_flags;

  /* gschem specific */
  char       *string = NULL;
  int i;

  const char *name_label_text;
  const char *name_label_text_add;
  const char *name_label_text_edit;

  const char *name_entry_tip;
  const char *name_list_tip;
  const char *name_list_add_tip;
  const char *name_list_edit_tip;
  const char *value_entry_tip;
  const char *value_entry_add_tip;
  const char *value_entry_edit_tip;
  const char *visibility_tip;

  ThisDialog = w_current->aewindow;

  if (!ThisDialog) {

    name_entry_tip       = _("Enter or type an attribute name"); /* common */
    name_label_text_add  = _("<b>Add Attribute</b>");
    name_label_text_edit = _("<b>Edit Attribute</b>");

    name_list_add_tip    = _("Select the attribute name to add");
    name_list_edit_tip   = _("Select the name of the attribute to edit");

    value_entry_add_tip  = _("Input a value for the new attribute");
    value_entry_edit_tip = _("Input or edit the value of the attribute");

    visibility_tip       = _("Enable or disable visibility of the attribute");

    if (SAE_ADD_MODE == flag) {
      name_label_text    = name_label_text_add;
      name_list_tip      = name_list_add_tip;
      value_entry_tip    = value_entry_add_tip;
      response           = GTK_RESPONSE_ACCEPT;
      dialog_flags       = GSCHEM_DIALOG_MODAL;
    }
    else {
      name_label_text    = name_label_text_edit;
      name_list_tip      = name_list_edit_tip;
      value_entry_tip    = value_entry_edit_tip;
      response           = GTK_RESPONSE_APPLY;
      dialog_flags       = GSCHEM_MODELESS_DIALOG;
    }

    ThisDialog = gschem_dialog_new_with_buttons(_("Single Attribute Editor"),
                                                GTK_WINDOW(w_current->main_window),
                                                dialog_flags,
                                                IDS_SINGLE_ATTRIR, w_current,
                                                GTK_STOCK_CLOSE, GTK_RESPONSE_REJECT,
                                                GTK_STOCK_APPLY, response,
                                                NULL);

    vbox = GTK_DIALOG(ThisDialog)->vbox;
    gtk_container_set_border_width(GTK_CONTAINER(ThisDialog),
                                   DIALOG_BORDER_SPACING);
    gtk_box_set_spacing(GTK_BOX(vbox), DIALOG_V_SPACING);

    /* Main Body Label */
    label = geda_aligned_label_new(name_label_text, 0, 0);
    geda_label_set_use_markup ( GEDA_LABEL(label), TRUE);
    gtk_container_add (GTK_CONTAINER (vbox), label);

    /* Create alignment widget for main body and add to vbox */
    alignment = gtk_alignment_new(0,0,1,1);
    gtk_alignment_set_padding(GTK_ALIGNMENT(alignment), 0, 0,
                              DIALOG_INDENTATION, 0);
    gtk_box_pack_start(GTK_BOX(vbox), alignment, TRUE, TRUE, 0);

    /* Create the "body" table and add to the alignment widget */
    table = gtk_table_new (3, 2, FALSE);
    gtk_table_set_row_spacings(GTK_TABLE(table), DIALOG_V_SPACING);
    gtk_table_set_col_spacings(GTK_TABLE(table), DIALOG_H_SPACING);
    gtk_container_add (GTK_CONTAINER (alignment), table);

    /* Name selection */
    name_label = geda_aligned_label_new (_("Name:"), 0, 0.5);
    gtk_table_attach (GTK_TABLE (table), name_label, 0, 1, 0, 1,
                      (GtkAttachOptions) (GTK_FILL),
                      (GtkAttachOptions) (GTK_FILL), 0, 0);

    attrib_combo_box_entry = gtk_combo_box_entry_new_text ();
    attrib_combo_entry = gtk_bin_get_child(GTK_BIN(attrib_combo_box_entry));
    gtk_table_attach (GTK_TABLE (table), attrib_combo_box_entry, 1, 2, 0, 1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);

    gtk_combo_box_set_focus_on_click (GTK_COMBO_BOX(attrib_combo_box_entry), FALSE);
    gtk_widget_set_tooltip_text (GTK_WIDGET(attrib_combo_box_entry), name_list_tip);
    gtk_widget_set_tooltip_text (GTK_WIDGET(attrib_combo_entry), name_entry_tip);

    /* Value entry */
    value_label = geda_aligned_label_new (_("Value:"), 0, 0.5);
    gtk_table_attach (GTK_TABLE (table), value_label, 0, 1, 1, 2,
                      (GtkAttachOptions) (GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);

    value_entry = gtk_entry_new ();

    gtk_table_attach (GTK_TABLE (table), value_entry, 1, 2, 1, 2,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gtk_entry_set_activates_default(GTK_ENTRY(value_entry), TRUE);
    gtk_widget_set_tooltip_text (GTK_WIDGET(value_entry), value_entry_tip);

    /* Visibility */
    visbutton = gtk_check_button_new_with_label (_("Visible"));
    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (visbutton), TRUE);
    gtk_table_attach (GTK_TABLE (table), visbutton, 0, 1, 2, 3,
                      (GtkAttachOptions) (GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gtk_widget_set_tooltip_text (GTK_WIDGET(visbutton), visibility_tip);

    show_options = x_attrib_option_menu_new();

    gtk_table_attach (GTK_TABLE (table), show_options, 1, 2, 2, 3,
                      (GtkAttachOptions) (GTK_FILL | GTK_EXPAND),
                      (GtkAttachOptions) (0), 0, 0);

    /** Set the relationships between the label and their Widgets **/
    geda_label_set_mnemonic_widget (GEDA_LABEL (name_label),  attrib_combo_entry);
    geda_label_set_mnemonic_widget (GEDA_LABEL (value_label), value_entry);

    atk_name_obj  = atk_widget_linked_label_new (name_label,  attrib_combo_entry );
    atk_value_obj = atk_widget_linked_label_new (value_label, value_entry );

    if ( atk_name_obj ) {
      atk_object_set_name        (atk_name_obj,  _("Atrribute Name List"));
      atk_object_set_description (atk_name_obj,     name_list_tip );
    }
    if ( atk_value_obj ) {
      atk_object_set_name        (atk_value_obj, _("Attribute Value Entry"));
      atk_object_set_description (atk_value_obj,    value_entry_tip );
    }

    if (!object) {
      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(visbutton), TRUE);
      /* show value only */
      gtk_option_menu_set_history (GTK_OPTION_MENU (show_options), 0);
    }

    g_object_set_data(G_OBJECT(ThisDialog), "mode_flag", GINT_TO_POINTER(flag));

    /* load the combo's tree with our list of attributes names */
    i = 0;
    string = (char *) s_attrib_get(i);
    while (string != NULL) {
      gtk_combo_box_append_text(GTK_COMBO_BOX(attrib_combo_box_entry), string);
      i++;
      string = (char *) s_attrib_get(i);
    }

    /* Add completion to attribute combo box entry */
    attrib_combo_entry_completion = gtk_entry_completion_new();
    gtk_entry_completion_set_model(attrib_combo_entry_completion,
                                   gtk_combo_box_get_model(GTK_COMBO_BOX(attrib_combo_box_entry)));
    gtk_entry_completion_set_text_column(attrib_combo_entry_completion, 0);
    gtk_entry_completion_set_inline_completion(attrib_combo_entry_completion, TRUE);
    gtk_entry_completion_set_popup_single_match(attrib_combo_entry_completion, FALSE);
    gtk_entry_set_completion(GTK_ENTRY(attrib_combo_entry), attrib_combo_entry_completion);

    GSCHEM_HOOKUP_OBJECT(ThisDialog, attrib_combo_entry, "attrib_combo_entry");
    GSCHEM_HOOKUP_OBJECT(ThisDialog, value_entry,        "value_entry");
    GSCHEM_HOOKUP_OBJECT(ThisDialog, visbutton,          "visbutton");
    GSCHEM_HOOKUP_OBJECT(ThisDialog, show_options,       "show_options");

    /* Connect Attribute Name Combo Entry widget in order to move focus
     * to the Value entry after changing the Attribute Name */
    g_signal_connect (attrib_combo_entry, "activate",
                      G_CALLBACK (callback_attrib_entry_activate),
                      value_entry);

    g_signal_connect (G_OBJECT (ThisDialog), "response",
                      G_CALLBACK (attribute_edit_dialog_response),
                      w_current);

    gtk_window_set_position (GTK_WINDOW (ThisDialog), GTK_WIN_POS_MOUSE);

    gtk_dialog_set_default_response(GTK_DIALOG(ThisDialog),
                                    GTK_RESPONSE_APPLY);

    gtk_widget_show_all(ThisDialog);

    if (flag == ID_ORIGIN_KEYBOARD) {
      gtk_widget_grab_focus(attrib_combo_entry);
    }
    else {
      gtk_widget_grab_focus(value_entry);
    }

    /* Tell our inherited on-selection change callback handler which
     * function to use */
    g_object_set (G_OBJECT (ThisDialog), DIALOG_DATA_SELECTION,
                  x_dialog_attrib_edit_update_selection, NULL);

    if (!object) {
      gtk_grab_add(ThisDialog);
    }

    w_current->aewindow = ThisDialog;

  }
  else { /* dialog already there */
    gtk_window_present(GTK_WINDOW(ThisDialog));
  }
  x_dialog_attrib_edit_update_selection (w_current, object);

}
void x_attrib_add_dialog (GschemToplevel *w_current, OBJECT *object)
{
  attrib_edit_dialog (w_current, object, SAE_ADD_MODE);
}
void x_attrib_edit_dialog (GschemToplevel *w_current, OBJECT *object)
{
  attrib_edit_dialog (w_current, object, SAE_EDIT_MODE);
}
#undef ThisDialog
/***************** End of Attrib Edit dialog box **********************/
