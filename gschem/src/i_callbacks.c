/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2013 Ales Hvezda
 * Copyright (C) 1998-2013 gEDA Contributors (see ChangeLog for details)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
#include <config.h>

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "gschem.h"
#include "x_menu.h"

#define I_DO_DECLARE
#include "i_command.h"

#ifdef HAVE_LIBDMALLOC
#include <dmalloc.h>
#endif

/*! \brief */
#define DELIMITERS ", "

/*! \todo Finish function documentation!!!
 *  \brief
 *  \par Function Description
 *
 */
/* every i_callback functions have the same footprint */
#define DEFINE_I_CALLBACK(name) \
	void i_callback_ ## name I_CALLBACK_ARGUMENTS

/*! \section callback-intro Callback Functions
 *
 * Don't use the widget parameter in these callback function, or do some
 * checking since these routines are usually called with widget = NULL,
 * data = 0 (will be w_current hack)
 *
 * \note WEH: The 4th parameter to the i_command_process function called
 * by most of the actions is an optional string pointer, typical
 * generated by keyboard, we don't utilize this here (yet) ;
 */

/*! \section HotKey Callback Functions */

/*! \brief Copy Object initiated by Keyboard Hoykey
 *  \par Function Description
 *  This is a callback function for the Copy hotkey action.
 */
DEFINE_I_CALLBACK(edit_copy_hotkey)
{
  if (w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      if (o_select_return_first_object(w_current)) {
        o_redraw_cleanstates(w_current);
        w_current->event_state = COPY;
        o_copy_start(w_current, wx, wy);
        w_current->event_state = ENDCOPY;
        w_current->inside_action = 1;
      }
    }
  }
}

/*! \brief Multi-Copy Object initiated by Keyboard Hoykey
 *  \par Function Description
 *  This is a callback function for the Multi-Copy hotkey action.
 */
DEFINE_I_CALLBACK(edit_mcopy_hotkey)
{
  if (w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      if (o_select_return_first_object(w_current)) {
        o_redraw_cleanstates(w_current);
        w_current->event_state = MCOPY;
        o_copy_start(w_current, wx, wy);
        w_current->event_state = ENDMCOPY;
        w_current->inside_action = 1;
      }
    }
  }
}

/*! \brief Move initiated by the Keyboard Hotkeys
 *  \par Function Description
 *  This is a callback function for the Move hotkey action.
 */
DEFINE_I_CALLBACK(edit_move_hotkey)
{
  if (w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      if (o_select_return_first_object(w_current)) {
        o_redraw_cleanstates(w_current);
        o_move_start(w_current, wx, wy);
        w_current->event_state = ENDMOVE;
        w_current->inside_action = 1;
      }
    }
  }
}

/*! \brief Rotate initiated by the Keyboard Hotkeys
 *  \par Function Description
 *  This is a callback function for the Rotate hotkey action.
 *  This function rotate all objects in the selection list by 90 degrees.
 */
DEFINE_I_CALLBACK(edit_rotate_hotkey)
{
  if (w_current != NULL) {
    GList *object_list;
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      /* If inside an appropriate action, send a button 2 released,
       * so rotating will be handled by x_event.c */
      if ( w_current->inside_action &&
           (w_current->event_state == ENDCOMP ||
            w_current->event_state == ENDTEXT ||
            w_current->event_state == ENDMOVE ||
            w_current->event_state == ENDCOPY ||
            w_current->event_state == ENDMCOPY ||
            w_current->event_state == ENDPASTE )) {
          GdkEvent* event;

          event = gdk_event_new(GDK_BUTTON_RELEASE);
          ((GdkEventButton*) event)->button = 2;
          x_event_button_released (NULL, (GdkEventButton *) event, w_current);
          gdk_event_free(event);
        }
      else {
        o_redraw_cleanstates(w_current);

        object_list = geda_list_get_glist( w_current->toplevel->page_current->selection_list );

        if (object_list) {
          /* Allow o_rotate_world_update to redraw the objects */
          o_rotate_world_update(w_current, wx, wy, 90, object_list);
        }

        w_current->event_state = SELECT;
        w_current->inside_action = 0;
      }
    }
  }
}

/*! \brief Mirror initiated by the Keyboard Hotkeys
 *  \par Function Description
 *  This is a Hotkey callback function for the Mirror command
 */
DEFINE_I_CALLBACK(edit_mirror_hotkey)
{
  if (w_current != NULL) {
    GList *object_list;
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_redraw_cleanstates(w_current);

      object_list = geda_list_get_glist( w_current->toplevel->page_current->selection_list );

      if (object_list) {
        o_mirror_world_update(w_current, wx, wy, object_list);
      }

      w_current->event_state = SELECT;
      w_current->inside_action = 0;
    }
  }
}

/*! \brief Start pasting clipboard contents (hotkey version)
 *  \par Function Description
 *  It's not entirely clear what the difference is between this and
 *  i_callback_clipboard_paste()...
 */
DEFINE_I_CALLBACK(clipboard_paste_hotkey)
{

  if (w_current != NULL) {
    TOPLEVEL *toplevel = w_current->toplevel;
    GList *object_list = NULL;
    int wx, wy;

    if (x_event_get_pointer_position (w_current, TRUE, &wx, &wy)) {

      object_list = x_clipboard_get (w_current);

      if (object_list != NULL) {
        s_delete_object_glist (toplevel, object_buffer[0]);
        object_buffer[0] = object_list;
        o_buffer_paste_start (w_current, wx, wy, 0);
      }
    }
  }
}
/*! \brief Paste Buffer 1 initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Paste Buffer 1 hotkey action.
 */
DEFINE_I_CALLBACK(buffer_paste1_hotkey)
{
  if ((w_current != NULL) && (object_buffer[1] != NULL)) {
    int wx, wy;
    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_buffer_paste_start(w_current, wx, wy, 1);
    }
  }
}

/*! \brief Paste Buffer 2 initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Paste Buffer 2 hotkey action.
 */
DEFINE_I_CALLBACK(buffer_paste2_hotkey)
{
  if ((w_current != NULL) && (object_buffer[2] != NULL)) {
    int wx, wy;
    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_buffer_paste_start(w_current, wx, wy, 2);
    }
  }
}

/*! \brief Paste Buffer 3 initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Paste Buffer 3 hotkey action.
 */
DEFINE_I_CALLBACK(buffer_paste3_hotkey)
{
  if ((w_current != NULL) && (object_buffer[3] != NULL)) {
    int wx, wy;
    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_buffer_paste_start(w_current, wx, wy, 3);
    }
  }
}

/*! \brief Paste Buffer 4 initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Paste Buffer 4 hotkey action.
 */
DEFINE_I_CALLBACK(buffer_paste4_hotkey)
{
  if ((w_current != NULL) && (object_buffer[4] != NULL)) {
    int wx, wy;
    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_buffer_paste_start(w_current, wx, wy, 4);
    }
  }
}

/*! \brief Paste Buffer 5 initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Paste Buffer 5 hotkey action.
 */
DEFINE_I_CALLBACK(buffer_paste5_hotkey)
{
  if ((w_current != NULL) && (object_buffer[5] != NULL)) {
    int wx, wy;
    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_buffer_paste_start(w_current, wx, wy, 5);
    }
  }
}

/*! \brief Zoom Extents initiated by Keyboard Hoykey
 *  \par Function Description
 *  This is a callback function for the Zoom Extents hotkey action.
 */
DEFINE_I_CALLBACK(view_zoom_box_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, FALSE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      a_zoom_box_start(w_current, wx, wy);

      w_current->inside_action = 1;
      i_set_state(w_current, ZOOMBOXEND);
    }
  }
}
/*! \brief Zoom In initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Zoom In hotkey action.
 *  \note
 *  repeat middle shortcut would get into the way of what user is try
 *  to do
 */
DEFINE_I_CALLBACK(view_zoom_in_hotkey)
{
  if(w_current != NULL) {
    a_zoom(w_current, ZOOM_IN_DIRECTIVE, HOTKEY, 0);
    if (w_current->undo_panzoom) {
      o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
    }
  }
}

/*! \brief Zoom Out initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Zoom Out hotkey action.
 *
 *  \note
 *  repeat middle shortcut would get into the way of what user is try to do
 */
DEFINE_I_CALLBACK(view_zoom_out_hotkey)
{
  if(w_current != NULL) {
    a_zoom(w_current, ZOOM_OUT_DIRECTIVE, MENU, 0);
    if (w_current->undo_panzoom) {
      o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
    }
  }
}

/*! \brief Zoom Pan initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Zoom Pan Hotkey action.
 */
DEFINE_I_CALLBACK(view_pan_hotkey)
{
  if(w_current != NULL) {

    int wx, wy;

    if (!x_event_get_pointer_position(w_current, FALSE, &wx, &wy))
      return;

    a_pan(w_current, wx, wy);

    if (w_current->undo_panzoom) {
      o_undo_savestate(w_current, UNDO_VIEWPORT_ONLY);
    }
  }
}
/*! \brief Callback function that moves the viewport to the left.
 *  \par Function Description
 * The distance can be set with "keyboardpan-gain" scheme callback.
 */
DEFINE_I_CALLBACK(view_pan_left)
{
  if(w_current != NULL)
    a_pan_mouse(w_current, w_current->keyboardpan_gain, 0);
}

/*! \brief Callback function that moves the viewport to the right.
 *  \par Function Description
 * The distance can be set with "keyboardpan-gain" scheme callback.
 */
DEFINE_I_CALLBACK(view_pan_right)
{
  if(w_current != NULL)
    a_pan_mouse(w_current, -w_current->keyboardpan_gain, 0);
    /* yes, that's a negative sign there */
}

/*! \brief Callback function that moves the viewport up.
 *  \par Function Description
 * The distance can be set with "keyboardpan-gain" scheme callback.
 */
DEFINE_I_CALLBACK(view_pan_up)
{
  if(w_current != NULL)
    a_pan_mouse(w_current, 0, w_current->keyboardpan_gain);
}

/*! \brief Callback function that moves the viewport down.
 *  \par Function Description
 * The distance can be set with "keyboardpan-gain" scheme callback.
 */
DEFINE_I_CALLBACK(view_pan_down)
{
  if(w_current != NULL)
    a_pan_mouse(w_current, 0, -w_current->keyboardpan_gain);
    /* yes, that's a negative sign there */
}

/*! \brief Add Net initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Net Hotkey.
 */
DEFINE_I_CALLBACK(add_net_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);
      o_net_reset(w_current);

      /* need to click */
      i_set_state(w_current, STARTDRAWNET);

      o_net_start(w_current, wx, wy);

      w_current->event_state=DRAWNET;
      w_current->inside_action = 1;
    }
  }
}

/*! \brief Add Bus initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Bus hotkey action.
 */
DEFINE_I_CALLBACK(add_bus_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);

      /* need to click */
      i_set_state(w_current, STARTDRAWBUS);

      o_bus_start(w_current, wx, wy);

      w_current->event_state=DRAWBUS;
      w_current->inside_action = 1;
    }
  }
}

/*! \brief Add Line initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Line hotkey action.
 */
DEFINE_I_CALLBACK(add_line_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);

      o_line_start(w_current, wx, wy);

      w_current->inside_action = 1;
      i_set_state(w_current, ENDLINE);
    }
  }
}

/*! \brief Add Box initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Box hotkey action.
 */
DEFINE_I_CALLBACK(add_box_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {
      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);

      o_box_start(w_current, wx, wy);

      w_current->inside_action = 1;
      i_set_state(w_current, ENDBOX);
    }
  }
}

/*! \brief Add Circle initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Circle hotkey action.
 */
DEFINE_I_CALLBACK(add_circle_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);

      o_circle_start(w_current, wx, wy);

      w_current->inside_action = 1;
      i_set_state(w_current, ENDCIRCLE);
    }
  }
}

/*! \brief Add Arc initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Arc hotkey action.
 */
DEFINE_I_CALLBACK(add_arc_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);

      o_arc_start(w_current, wx, wy);

      w_current->inside_action = 1;
      i_set_state(w_current, ENDARC);
    }
  }
}

/*! \brief Add Pin initiated by Keyboard Hotkey
 *  \par Function Description
 *  This is a callback function for the Add Pin hotkey action.
 */
DEFINE_I_CALLBACK(add_pin_hotkey)
{
  if(w_current != NULL) {
    int wx, wy;

    if (x_event_get_pointer_position(w_current, TRUE, &wx, &wy)) {

      o_redraw_cleanstates(w_current);
      o_invalidate_rubber (w_current);

      o_pin_start(w_current, wx, wy);

      w_current->inside_action = 1;
      i_set_state(w_current, ENDPIN);
    }
  }
}

/*! \section file-menu File Menu Callback Functions */

/*! \brief Create New Blank Page
 *  \par Function Description
 *  This is a callback function for the File New API.
 *  The function calls i_command to process the action.
 *  \note the file-new action is similar to page new but does
 *  not automatically add a title-block
 */
DEFINE_I_CALLBACK(file_new)
{
  i_command_process(w_current, "file-new", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief File Open action
 *  \par Function Description
 *  This is a callback function for the File Open API.
 *  The function calls i_command to process the action.
 */
DEFINE_I_CALLBACK(file_open)
{
  i_command_process(w_current, "file-open", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Save File command action
 *  \par Function Description
 *  This is a callback function for the File Save API
 *  The function calls i_command to process the action.
 */
DEFINE_I_CALLBACK(file_save)
{
  i_command_process(w_current, "file-save", 0, NULL, ID_ORIGIN_SCM);
}

/*! \section buffer-scheme Scheme Callback Buffer Functions */

/*! \brief Copy selection to Buffer 1.
 *  \par Function Description
 *   Copies the current selection to the Buffer 1.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_copy1)
{
  i_command_process(w_current, "clipboard-copy", 1, "Copy 1", ID_ORIGIN_MENU);
}

/*! \brief Copy selection to Buffer 2.
 *  \par Function Description
 *   Copies the current selection to the Buffer 2.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_copy2)
{
  i_command_process(w_current, "clipboard-copy", 2, "Copy 2", ID_ORIGIN_MENU);
}

/*! \brief Copy selection to Buffer 3.
 *  \par Function Description
 *   Copies the current selection to the Buffer 3.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_copy3)
{
  i_command_process(w_current, "clipboard-copy", 3, "Copy 3", ID_ORIGIN_MENU);
}

/*! \brief Copy selection to Buffer 4.
 *  \par Function Description
 *   Copies the current selection to the Buffer 4.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_copy4)
{
  i_command_process(w_current, "clipboard-copy", 4, "Copy 4", ID_ORIGIN_MENU);
}

/*! \brief Copy selection to Buffer 5.
 *  \par Function Description
 *   Copies the current selection to the Buffer 5.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_copy5)
{
  i_command_process(w_current, "clipboard-copy", 5, "Copy 5", ID_ORIGIN_MENU);
}

/*! \brief Cut selection to Buffer 1.
 *  \par Function Description
 *   Cut the current selection to the Buffer 1.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_cut1)
{
  i_command_process(w_current, "clipboard-cut", 1, "Cut 1", ID_ORIGIN_MENU);
}

/*! \brief Cut selection to Buffer 2.
 *  \par Function Description
 *   Cut the current selection to the Buffer 2.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_cut2)
{
  i_command_process(w_current, "clipboard-cut", 2, "Cut 2", ID_ORIGIN_MENU);
}

/*! \brief Cut selection to Buffer 3.
 *  \par Function Description
 *   Cut the current selection to the Buffer 3.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_cut3)
{
  i_command_process(w_current, "clipboard-cut", 3, "Cut 3", ID_ORIGIN_MENU);
}

/*! \brief Cut selection to Buffer 4.
 *  \par Function Description
 *   Cut the current selection to the Buffer 4.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_cut4)
{
  i_command_process(w_current, "clipboard-cut", 4, "Cut 4", ID_ORIGIN_MENU);
}

/*! \brief Cut selection to Buffer 5.
 *  \par Function Description
 *   Cut the current selection to the Buffer 5.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_cut5)
{
  i_command_process(w_current, "clipboard-cut", 5, "Cut 5", ID_ORIGIN_MENU);
}

/*! \brief Start pasting contents of Buffer 1.
 *  \par Function Description
 *   Paste the contents of Buffer 1.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_paste1)
{
  i_command_process(w_current, "clipboard-paste", 1, "Paste 1", ID_ORIGIN_MENU);
}

/*! \brief Start pasting contents of Buffer 2.
 *  \par Function Description
 *   Paste the contents of Buffer 2.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_paste2)
{
  i_command_process(w_current, "clipboard-paste", 2, "Paste 2", ID_ORIGIN_MENU);
}

/*! \brief Start pasting contents of Buffer 3.
 *  \par Function Description
 *   Paste the contents of Buffer 3.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_paste3)
{
  i_command_process(w_current, "clipboard-paste", 3, "Paste 3", ID_ORIGIN_MENU);
}

/*! \brief Start pasting contents of Buffer 4.
 *  \par Function Description
 *   Paste the contents of Buffer 4.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_paste4)
{
  i_command_process(w_current, "clipboard-paste", 4, "Paste 4", ID_ORIGIN_MENU);
}

/*! \brief Start pasting contents of Buffer 5.
 *  \par Function Description
 *   Paste the contents of Buffer 5.
 *  \note We use our narg argument to pass the buffer ID and our
 *        string pointer to pass the middle button message
 */
DEFINE_I_CALLBACK(buffer_paste5)
{
  i_command_process(w_current, "clipboard-paste", 5, "Paste 5", ID_ORIGIN_MENU);
}


/*! \brief Page Close
 *  \par Function Description
 *  This is a callback function for the New Page API.
 *  The function calls i_command to process the action.
 */
DEFINE_I_CALLBACK(page_close)
{
  i_command_process(w_current, "page-close", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Page Discard
 *  \par Function Description
 *  This is a callback function for the Discard Page API.
 *  The function calls i_command to process the action.
 */
DEFINE_I_CALLBACK(page_discard)
{
  i_command_process(w_current, "page-discard", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Ales' catch all misc callback
 *  \par Function Description
 *
 *  \note this is a critical function
 */
DEFINE_I_CALLBACK(misc)
{
}

/*! \brief Ales' second catch all misc callback
 *  \par Function Description
 *
 *  \note this is not a critical function
 */
DEFINE_I_CALLBACK(misc2)
{
}

/*! \brief Ales' third catch all misc callback
 *  \par Function Description
 *
 *  \note this is the third misc callback responder
 */
DEFINE_I_CALLBACK(misc3)
{
}

/*! \brief Cancel Everthing
 *  \par Function Description
 *
 *  \note
 *  HACK: be sure that you don't use the widget parameter in this one,
 *  since it is being called with a null, I suppose we should call it
 *  with the right param.
 */
DEFINE_I_CALLBACK(cancel)
{
  TOPLEVEL *toplevel = w_current->toplevel;
  GValue value = { 0, };

  if (w_current->event_state == ENDCOMP &&
      w_current->cswindow) {
    /* user hit escape key when placing components */

    /* Undraw any outline of the place list */
    o_place_invalidate_rubber (w_current, FALSE);
    w_current->rubber_visible = 0;

    /* De-select the lists in the component selector */
    x_compselect_deselect (w_current);

    /* Present the component selector again */
    g_value_init (&value, G_TYPE_BOOLEAN);
    g_value_set_boolean (&value, FALSE);
    g_object_set_property (G_OBJECT(w_current->cswindow), "hidden", &value);
  }

  if (w_current->inside_action) {
    /* If we're cancelling from a move action, re-wind the
     * page contents back to their state before we started */
    if (w_current->event_state == MOVE ||
        w_current->event_state == ENDMOVE)
      o_move_cancel (w_current);

    /* If we're cancelling from a grip action, call the specific cancel
     * routine to reset the visibility of the object being modified */
    if (w_current->event_state == GRIPS)
      o_grips_cancel (w_current);
  }

  /* Free the place list and its contents. If we were in a move
   * action, the list (refering to objects on the page) would
   * already have been cleared in o_move_cancel(), so this is OK. */

  s_delete_object_glist(toplevel, toplevel->page_current->place_list);
  toplevel->page_current->place_list = NULL;

  /* leave this on for now... but it might have to change */
  /* this is problematic since we don't know what the right mode */
  /* (when you cancel inside an action) should be */
  i_set_state(w_current, SELECT);

  /* clear the key guile command-sequence */
  g_keys_reset (w_current);

  if (w_current->inside_action) {
     o_invalidate_all (w_current);
  }
  w_current->inside_action=0;
}

/*! \section help-menu Help Menu Callback Functions */

/*! \brief Help About Action Callback Responder API Function
 *  \par Function Description
 *  This is a callback function for the Help About API
 *  The function calls i_command to launch the Help About Dialog.
 */
DEFINE_I_CALLBACK(help_show_manual)
{
  i_command_process(w_current, "help-show-manual", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Help Hotkeys Action Callback Responder API Function
 *  \par Function Description
 *  This is a callback function for the Help Hotkeys API
 *  The function calls i_command to launch the Help Hotkeys Dialog.
 *
 *  \note
 *  WEH: like it!, could have icons too!
 */
DEFINE_I_CALLBACK(help_show_hotkeys)
{
  i_command_process(w_current, "help-show-hotkeys", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Help About Action Callback Responder API Function
 *  \par Function Description
 *  This is a callback function for the Help About API
 *  The function calls i_command to launch the Help About Dialog.
 */
DEFINE_I_CALLBACK(help_show_faq)
{
  i_command_process(w_current, "help-show-faq", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Help About Action Callback Responder API Function
 *  \par Function Description
 *  This is a callback function for the Help About API
 *  The function calls i_command to launch the Help About Dialog.
 */
DEFINE_I_CALLBACK(help_show_wiki)
{
  i_command_process(w_current, "help-show-wiki", 0, NULL, ID_ORIGIN_SCM);
}

/*! \brief Help About Action Callback Responder API Function
 *  \par Function Description
 *  This is a callback function for the Help About API
 *  The function calls i_command to launch the Help About Dialog.
 */
DEFINE_I_CALLBACK(help_show_about)
{
  i_command_process(w_current, "help-show-about", 0, NULL, ID_ORIGIN_SCM);
}

/* these is a special wrapper function which cannot use the above */
/* DEFINE_I_CALLBACK macro */

/*! \todo Finish function documentation!!!
 *  \brief
 *  \par Function Description
 *
 *  \note
 *  When invoked (via signal delete_event), closes the current window
 *  if this is the last window, quit gschem
 *  used when you click the close button on the window which sends a DELETE
 *  signal to the app
 */
bool i_callback_close_wm ( GtkWidget *widget, GdkEvent *event,
                           GSCHEM_TOPLEVEL* w_current )
{
  x_window_close(w_current);

  /* stop further propagation of the delete_event signal for window: */
  /*   - if user has cancelled the close the window should obvioulsy */
  /*   not be destroyed */
  /*   - otherwise window has already been destroyed, nothing more to */
  /*   do */
  return TRUE;
}
